---
layout: post
title: Audio-变调算法
categories: Audio
description: Audio-变调算法
keywords: Audio, 频移
original: true
typora-root-url: ..\..\
---

有时，我们需要对声音做变调处理，满足某种特定的使用场景，在此做个记录。

# 分类

目前变调算法从作用域来说分两种：

- 时域算法：优点是直接操作样本，无需重采样处理，计算量小，缺点是声音片段衔接处容易出现跳变，影响音频质量。
- 频域算法：优点是更精确的处理样本，缺点是计算量大。

# 时域算法

基本上分两步操作：

1. 音频数据重采样
2. 时域延拓或裁剪



## 音频数据重采样

音频重采样分为上采样和下采样：

- 下采样(抽取)：新采样率 < 原采样率

- 上采样(插值)：新采样率 > 原采样率

由数字信号处理中，时域信号和频域信号的时-频对偶特性可知：

- 时域的抽取，下采样，对应频域的延拓。
- 时域的插值，上采样，对应频域的压缩。

如果对信号的频率成分不做限制的话，频域的延拓可能会引发频谱混叠，频域的压缩可能会引发频谱镜像，因此，下采样之前，可能要经过滤波器滤波来防止混叠，即抗混叠滤波(anti-aliasing filter)，上采样之后，可能也要经过滤波处理，即抗镜像滤波(anti-image filter)。

举例：

原始信号如下(Fs为采样率，Fm为信号的最大频率)：

![](/images/audio/resample1.png)



当Fs/2小于Fm，重叠部分就是频谱混叠：

![](/images/audio/resample2.png)

在上采样后，因为会采样内插值算法，可能会因为不完美的滤波引入不需要的频谱镜像：

![](/images/audio/resample3.png)

> 总结：下采样过程：低通->抽值    上采样过程：插值->低通

### 抽取算法

简单粗暴实现：


$$
y(n)=x(M n) \quad n \geq 0 \quad M \geq 1
$$

因为是离散信号，M肯定是整数，因此成倍数的抽取，如果要完成采样率非倍数的变化，需要配合插值来完成。

### 插值算法

主流插值算法就几种：

- 线性插值：当采样率远大于音频最高频率时可以使用，简单高效。
- 三次样条插值：当要求信号更平滑时，可以使用。
- 香农插值：配合kaiser窗函数使用，计算量很大，性价比不如三次样条插值。

主要对比线性插值和三次样条内插。

> tips：简单的理解插值，就是两个采样点之间先直接插入N个0值，但这势必会引入高频成分，因此一般选用低通滤波来平滑处理。

#### 线性插值


$$
h_{lin}[n] =\left\{\begin{array}{ll}
1-|n| / L, & |n| \leqslant L \\
0, & \text { else }
\end{array}\right.
$$


当L=5时，如下波形：

![](/images/audio/lin1.JPG)

实际运用效果如下：

![](/images/audio/lin2.JPG)

线性插值只用到内插的位置两旁的两个样本，就是把两个样本用直线连接后，该直线在对应内插位置上的的值就是所求的内插值。


实际运用中，对L归一化处理，离散数据中使用如下：


$$
y(n')=(1-p)x(n)+px(n+1) \quad n \geq 0 \quad 1 \geq p \geq 0
$$


#### 三次样条插值


$$
h_{cu}[n] = \begin{cases}

(a+2)|n / L|^{3}-(a+3)|n / L|^{2}+1, & 0 \leqslant|n| \leqslant L \\
a|n / L|^{3}-5 a|n / L|^{2}+8 a|n / L|-4 a, & L \leqslant|n| \leqslant 2 L \\
0,& else

\end{cases}
$$


当L=5，a=-0.5时，Cubic函数形状如下：

![](/images/audio/cubic1.JPG)

实际运用效果如下：

![](/images/audio/cubic2.JPG)

三次样条插值会用到内插位置两旁的四个样本，即左右各两个，曲线类似于对低通滤波器(sinc函数)进行截取后的曲线。

实际运用中，对L归一化处理，如下：


$$
h_{cu}(x) = \left\{\begin{array}{ll}
(a+2)|x|^{3}-(a+3)|x|^{2}+1, & 0 \leqslant|x| \leqslant 1 \\
a|x|^{3}-5 a|x|^{2}+8 a|x|-4 a, & 1 \leqslant|x| \leqslant 2 \\
0, & e l s e
\end{array}\right.
$$


离散数据中使用如下(C参数可调)：


$$
y(n')=(C_0p^3+C_1p^2+C_2p^1+C_3p^0)x(n) \\  +(C_4p^3+C_5p^2+C_6p^1+C_7p^0)x(n+1) \\ +(C_8p^3+C_9p^2+C_{10}p^1+C_{11}p^0)x(n+2) \\ +(C_{12}p^3+C_{13}p^2+C_{14}p^1+C_{15}p^0)x(n+3), \\  \quad n \geq 0 \quad 1 \geq p \geq 0
$$


#### 对比

观察上面两个插值器的频谱图如下：

![](/images/audio/compare.JPG)

上图蓝色实线为线性插值频谱，红色虚线为三次样条插值频谱。

对比线性插值以及三次样条插值，可以发现在 $ \omega<\frac{\pi}{L} $ 处，三次样条的旁瓣较宽，而在 $ \omega>\frac{\pi}{L} $ 处，三次样条的能量更小（幅度更低）,即三次样条更接近于低通滤波器，因此三次样条插值会比线性插值的效果更好。

## 时域延拓或裁剪

典型的有SOLA、TDHS(Time-Domain Harmonic Sampling)、WSOLA和PSOLA几种，其中SOLA是最基本的，其它都是基于SOLA上的变种，下面主要介绍SOLA算法。

SOLA是Synchronous-OverLap-Add的简写，是将音频数据切断成几十到几百毫秒的片段，然后把这些片段按跳选或重复的原则来重新组成音频数据，其中，在片段的衔接处，由于音频数据的不连贯，会产生跳变，引入杂音，为了解决这个问题，可以采用加窗处理，并利用互相关函数，开辟一个搜索窗口动态寻找最匹配的衔接片段，以达到音频片段的平滑衔接。

如下图所示：

![](/images/audio/sola.png)

当然如果遇到多通道数据，比如立体声，环绕声，由于要保证所有通道的数据时间的一致性，只能使用多通道的互相关均值来选定一个合适的滑动窗口。

# 频域算法

频域处理虽然计算量大，但看起来也确实非常直观，如下图所示：

![](/images/audio/vocoder.png)

主要分三部分：

1. FFT变换：将时域变换到频域。
2. 拉伸频率：相位尽量不变，幅值改变。
3. IFFT变换：将频域反变换到时域。