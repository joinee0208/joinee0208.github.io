---
layout: post
title: 认识设计模式-开篇
categoryies 设计模式
original: true
description: 设计模式-开篇
keywords: 设计模式
typora-root-url: ..\..
---

[1]:empty

## 前提

写代码也有好几年了，一直知道有这么一个东西，平常也知道几种模式，比如：单例，工厂，状态，观察者等，但一直没时间系统学习下到底什么是设计模式，趁这个机会，好好认识下它。

## 设计模式是什么

在 1994 年，由 Erich Gamma、Richard Helm、Ralph Johnson 和 John Vlissides 四人合著出版了一本名为 Design Patterns - Elements of Reusable Object-Oriented Software（中文译名：设计模式 - 可复用的面向对象软件元素） 的书，该书首次提到了软件开发中设计模式的概念。由此书名可以看出三点：

1.设计模式的作用域是面向对象软件编程，当然现在面向对象俨然成为一个思想，因此即使在非面向对象语言中也能应用，比如C语言中可以灵活使用观察者模式。 

2.设计模式的目的是可复用，如今的软件越做越大，发展为软件工程，而可复用可以让代码编制真正工程化，因此设计模式是软件工程的基石脉络，如同大厦的结构一样。

3.设计模式就是实现可复用的软件元素，这点从英文中不好理解，我个人理解元素就是经验，也就是说设计模式其实就是经验，把它著书也就是经验总结，这样，我们小白就可以阅读大牛的经验总结悟出大牛的经验，从而把设计模式发扬光大，因而推动整个软件行业的积极发展。

因此，我理解设计模式就是为了使软件可复用的经验总结,而且是为面向对象编程服务的。

## 设计模式的准则

我们知道设计模式是为了给面向对象编程实现可复用使用的，那为了达到这个目的，肯定需要一些准则，也就是说为了达到可复用，需要哪些条件。至今，大牛们总结了以下七条(很多书中写六条，其实准则都是大家总结出来的，随着软件的发展，会有更多准则被总结出)：

1. 单一职责原则(Single Responsibility Principle,SRP)：类的职责要单一，不能将太多的职责放在一个类中
2. 开闭原则(Open-Closed Principle,OCP )：对扩展开放，对修改关闭
3. 里氏代换原则( Liskov Substitution Principle ,LSP )：任何基类可以出现的地方,子类也可以出现
4. 依赖倒转原则( Dependence Inversion Principle ,DIP )：要依赖抽象,而不要依赖具体的实现
5. 合成/聚合复用原则(Composite/Aggregate ReusePrinciple ，CARP)：要尽量使用对象组合,而不是继承关系达到软件复用的目的
6. 迪米特法则(Law of Demeter，LoD：系统中的类,尽量不要与其他类互相作用,减少类之间的耦合度
7. 接口隔离法则(Interface Segregation Principle，ISL）：客户端不应该依赖那些它不需要的接口

如何理解这些准则呢？其实软件世界和现实世界是相通的，人类在软件世界做出的任何东西都是有现实参考的，为了达到可复用的条件，我们可以联想现实里一些可复用的例子来理解。

比如制作一个类人型机器人，单一职责原则使它产生了机器手和机器脚等部件，里氏代换原则可以让你自由更换满足连接接口的机器手，依赖倒转原则可以使机器脑控制机器手时无须关心是铁质机器手还是黄金机器手，迪米特法则让机器手指无须和机器脑联系，只需要和机器臂沟通，接口隔离原则使5个机器手指可以独立运作互不干扰，合成/聚合复用原则可以让一个机器人手臂拆下来安装在另一个机器人身上，开放封闭原则可以给机器人输入不同的指令来完成特定的需求。

正式因为在我们现实世界中，这些原则都悄然无息的存在着，所以我们的世界才井然有序的发展，因此，我们必须把这些规律原则提取出来，复制到软件虚拟世界，以构建一个新的世界。

## 设计模式有哪些

人类认识新事物都有个顺序，知道了设计模式的由来，作用以及准则，接下来就得认识下大牛们开发出来的设计模式到底有哪些。在《Design Patterns - Elements of Reusable Object-Oriented Software》中，包含23种设计模式(其实如今设计模式越来越多，已经不只这23种了)，分为三种类型：

1. 创建型模式
2. 结构型模式
3. 行为型模式

###	创建型模式

- 工厂模式（Factory Pattern）
- 抽象工厂模式（Abstract Factory Pattern）
- 单例模式（Singleton Pattern）
- 建造者模式（Builder Pattern）
- 原型模式（Prototype Pattern）

这些模式说白了就是一些避免直接使用类似`new`关键字的创建对象的方法。

###	结构型模式

- 适配器模式（Adapter Pattern）
- 桥接模式（Bridge Pattern）
- 过滤器模式（Filter、Criteria Pattern）
- 组合模式（Composite Pattern）
- 装饰器模式（Decorator Pattern）
- 外观模式（Facade Pattern）
- 享元模式（Flyweight Pattern）
- 代理模式（Proxy Pattern）

这些模式很好的定义了对象和对象之间的关联模型，从而使代码在大规模的软件工程中也能井然有序。

###	行为型模式

- 责任链模式（Chain of Responsibility Pattern）
- 命令模式（Command Pattern）
- 解释器模式（Interpreter Pattern）
- 迭代器模式（Iterator Pattern）
- 中介者模式（Mediator Pattern）
- 备忘录模式（Memento Pattern）
- 观察者模式（Observer Pattern）
- 状态模式（State Pattern）
- 空对象模式（Null Object Pattern）
- 策略模式（Strategy Pattern）
- 模板模式（Template Pattern）
- 访问者模式（Visitor Pattern）

以上的模型好比对象和对象之间的沟通交流，是在结构型模型上发展出来的类似社会关系。

## 设计模式的理解

怎么理解这些设计模式呢？上面已经说了，虚拟世界的规律大多都是从现实世界中总结出来的，就像这些设计模式，之所以分成创建型，结构型，行为型，那都是遵从事物从无到有，从有到秩序，从秩序到发展的规律。

我们先谈谈创建型模式，这5种创建型模式很好理解，类似我们地球的生物进化，单例模式类似单细胞生物，原型模式类似单细胞克隆，建造者模式类似多细胞生物，工厂模式类似低级生物，抽象工厂模式类似高等生物。5种模式依次以简单到复杂，低等到高等的顺序排列。

那么结构型模式其实也是类似，






